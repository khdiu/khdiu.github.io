<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>chapter2</title>
      <link href="/2022/03/07/computer-network(chapter2)/"/>
      <url>/2022/03/07/computer-network(chapter2)/</url>
      
        <content type="html"><![CDATA[<h1 id="Chapter2-application-layer"><a href="#Chapter2-application-layer" class="headerlink" title="Chapter2 application layer"></a>Chapter2 application layer</h1>]]></content>
      
      
      <categories>
          
          <category> computer network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>latex学习</title>
      <link href="/2022/03/03/latex/"/>
      <url>/2022/03/03/latex/</url>
      
        <content type="html"><![CDATA[<h1 id="Late学习"><a href="#Late学习" class="headerlink" title="Late学习"></a>Late学习</h1>]]></content>
      
      
      <categories>
          
          <category> latex </category>
          
      </categories>
      
      
        <tags>
            
            <tag> learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Database system(C2)</title>
      <link href="/2022/03/03/Database-system-C2/"/>
      <url>/2022/03/03/Database-system-C2/</url>
      
        <content type="html"><![CDATA[<h1 id="chapter2-Introduction-to-relation-model"><a href="#chapter2-Introduction-to-relation-model" class="headerlink" title="chapter2 Introduction to relation model"></a>chapter2 Introduction to relation model</h1><h2 id="outline"><a href="#outline" class="headerlink" title="outline"></a>outline</h2><ul><li>Structure of Relation Database</li><li>Database Schema</li><li>keys, integrity constrains</li><li>Schema Diagram</li><li>Relational Query Languages</li><li>The Relational Algebra</li></ul><h3 id="Data-model"><a href="#Data-model" class="headerlink" title="Data model"></a>Data model</h3><p>Purpose: To represent data in an understandable way</p><p>Define: Integrated collection of concepts for describing data, relationships between data, and constraints on the data in an organization</p><p><strong>Data Model comprises:</strong></p><ul><li>A structural part</li><li>Possibly a set of integrity rules</li><li>a manipulative part</li></ul><h2 id="Relational-Model"><a href="#Relational-Model" class="headerlink" title="Relational Model"></a>Relational Model</h2><h3 id="Mathematical-Definition-of-Relation"><a href="#Mathematical-Definition-of-Relation" class="headerlink" title="Mathematical Definition of Relation"></a>Mathematical Definition of Relation</h3><ul><li><p>Formally, given sets D1, D2, …Dn</p><p>A relation r is a subset of D1*D2…*Dn</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>database system(W2)</title>
      <link href="/2022/03/03/database-system-C1/"/>
      <url>/2022/03/03/database-system-C1/</url>
      
        <content type="html"><![CDATA[<h1 id="Database-system"><a href="#Database-system" class="headerlink" title="Database system"></a>Database system</h1><h2 id="preview"><a href="#preview" class="headerlink" title="preview"></a>preview</h2><p>The benefits of database: </p><ul><li>control redundancy</li><li>share</li><li>maintain data integrity</li><li>allow data independence</li><li>perform automatic query optimization</li><li>allow concurrency</li><li>provide for backup and recovery</li><li>control security</li></ul><h2 id="Abstract-model"><a href="#Abstract-model" class="headerlink" title="Abstract model"></a>Abstract model</h2><img src="https://blogpicture01.oss-cn-beijing.aliyuncs.com/img/image-20220303091944959.png" alt="image-20220303091944959" style="zoom: 33%;"><p><strong>Conceptual model(information model for DB design):</strong></p><ul><li>Entity-Relationship data model (mainly for database design)</li></ul><p><strong>Machine model(include logical and physical model)</strong></p><ul><li>logical model:<ul><li>Network model<ul><li>Hierarchical model</li></ul></li><li>relational model</li><li>Object-based data models(Object-oriented and Object-relational)</li><li>Semistructured data model</li><li>Unstructured model</li></ul></li><li>physical model:</li><li>Describe how data is stored and accessed in the system</li></ul>]]></content>
      
      
      <categories>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件开发环境与工具</title>
      <link href="/2022/03/01/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E4%B8%8E%E5%B7%A5%E5%85%B7/"/>
      <url>/2022/03/01/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E4%B8%8E%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<h1 id="软件开发环境与工具"><a href="#软件开发环境与工具" class="headerlink" title="软件开发环境与工具"></a>软件开发环境与工具</h1><h2 id="1概述"><a href="#1概述" class="headerlink" title="1概述"></a>1概述</h2><ul><li>在软件工程学中，方法和工具是一个问题的两个方面</li><li><strong>方法</strong>是工具研制的先导</li><li><strong>工具</strong>是方法的具体体现</li><li>软件工程方法的研究成果需要转化为最终实现的软件工具和系统</li><li>软件开发环境是由工具构成的</li></ul><h3 id="1-1软件开发工具"><a href="#1-1软件开发工具" class="headerlink" title="1.1软件开发工具"></a>1.1软件开发工具</h3><ul><li><p>软件开发工具是用于辅助软件生命周期过程的基于计算机的工具</p></li><li><p>软件工具是指为支持计算机软件的开发、维护、模拟、移植或管理而研制的程序系统</p></li><li><p>软件工具通常由三部分组成：工具，工具接口，工具用户接口</p></li></ul><p><strong>软件开发工具的发展特点</strong></p><ol><li>软件开发工具由单个工具向多个工具集成化方向发展</li><li>重视用户界面的设计</li><li>不断采用新理论和新技术</li><li>软件工具的商品化推动了软件产业的发展，软件产业的发展，又反过来促进了软件工具的发展</li></ol><p><strong>软件开发工具5个方面的功能需求</strong></p><ol><li>认识与描述客观系统：<u>需求阶段</u></li><li>存储及管理开发过程中的信息：如配置管理，<strong>核心：</strong>保持数据的一致性</li><li>代码的编写和生成：编辑、编译、链接，<strong>核心</strong>：通过代码自动生成方式及软件重用提高效率</li><li>文档的编制与生成：World工具，<strong>核心：</strong>保持文档与软件的一致性</li><li>软件项目管理：为管理人员提供支持</li></ol><p>对应：需求工具、配置管理工具、编程工具、设计&#x2F;测试工具以及项目管理工具</p><p><strong>软件开发工具5个方面的性能要求</strong></p><ol><li>表达能力和描述能力</li><li>保持信息一致性的能力</li><li>使用的方便程度</li><li>工具的可靠程度</li><li>对硬件和软件环境的要求</li></ol><h3 id="1-2CASE工具概述"><a href="#1-2CASE工具概述" class="headerlink" title="1.2CASE工具概述"></a>1.2CASE工具概述</h3><p>CASE(Computer-Aided Software Engineering): 是一组工具和方法的集合，可以辅助软件开发生成周期各阶段进行软件开发，是软件工程发展的产物，例如：</p><ul><li>设计：Visio，Power Designer</li><li>版本管理：Clear case</li><li>集成开发环境：Visual Studio 2010</li></ul><h4 id="CASE工具要达到以下目标："><a href="#CASE工具要达到以下目标：" class="headerlink" title="CASE工具要达到以下目标："></a><strong>CASE工具要达到以下目标：</strong></h4><ol><li>高效及时完成开发工作</li><li>降低开发成本</li><li>达到软件的功能要求</li><li>取得较好的软件性能</li><li>降低软件维护费用</li></ol><p>核心：<strong>提高生产率，提高质量</strong></p><h4 id="CASE的作用："><a href="#CASE的作用：" class="headerlink" title="CASE的作用："></a><strong>CASE的作用：</strong></h4><ol><li>提供一个具有快速响应、早期查错功能的交互式开发环境</li><li>对软件的开发和维护过程中的许多环节实现自动化</li><li>通过一个强有力的图形接口，实现直观的程序设计</li></ol><img src="https://blogpicture01.oss-cn-beijing.aliyuncs.com/img/image-20220301143045412.png" alt="image-20220301143045412" style="zoom:67%;"><h4 id="CASE工具的分类："><a href="#CASE工具的分类：" class="headerlink" title="CASE工具的分类："></a><strong>CASE工具的分类：</strong></h4><ol><li>支持单个过程任务的工具，比如：编译器、连接器等</li><li>工作台支持某一过程某些活动或所有活动，比如C语言集成开发环境</li><li>环境支持软件过程大部分活动或所有活动</li></ol><h4 id="CASE工具台："><a href="#CASE工具台：" class="headerlink" title="CASE工具台："></a><strong>CASE工具台：</strong></h4><p>一个CASE工作台是一组工具集，支持图形化设计、编码实现或测试等特定的软件开发阶段，可以分为：</p><ol><li>分析和设计工作台（上游CASE工具）</li><li>程序设计工作台（下游CASE工具）</li><li>测试工作台</li></ol><h4 id="CASE软件的特点："><a href="#CASE软件的特点：" class="headerlink" title="CASE软件的特点："></a>CASE软件的特点：</h4><ol><li>将软件生存期各个阶段的工作连接在一起</li><li>收集和连接软件系统中从最初需求到软件维护各个阶段的所有信息</li><li>用人工智能技术实现软件开发和维护工作的自动化</li></ol><h4 id="方法的发展："><a href="#方法的发展：" class="headerlink" title="方法的发展："></a>方法的发展：</h4><ol><li>20世纪70年代  结构化方法</li><li>20世纪80年代  面向对象方法</li><li>20世纪90年代  快速原型法</li></ol><h4 id="CASE的集成化工具发展趋势"><a href="#CASE的集成化工具发展趋势" class="headerlink" title="CASE的集成化工具发展趋势"></a>CASE的集成化工具发展趋势</h4><ol><li>界面集成</li><li>数据集成</li><li>控制集成</li><li>过程集成</li></ol><h5 id="CASE工具的界面集成"><a href="#CASE工具的界面集成" class="headerlink" title="CASE工具的界面集成"></a>CASE工具的界面集成</h5><ul><li><p>界面集成是指一个系统中的工具使用共同的风格，以及采用共同的用户交互标准</p></li><li><p>界面集成的目的是通过减轻用户的认知负担而提高用户使用环境的效率和效果</p></li><li><p>如：</p><img src="https://blogpicture01.oss-cn-beijing.aliyuncs.com/img/image-20220301151538584.png" style="zoom: 50%;"></li></ul><h5 id="CASE工具的数据集成"><a href="#CASE工具的数据集成" class="headerlink" title="CASE工具的数据集成"></a>CASE工具的数据集成</h5><ul><li>数据集成是指不同软件工程能相互交换数据</li><li>数据集成的目的是确认开发环境中的所有信息都作为一个整体数据被各部分操作或转换</li><li>数据集成包括：通用性、非冗余性、一致性、同步性和交换性五个方面属性</li></ul><h5 id="CASE工具的控制集成"><a href="#CASE工具的控制集成" class="headerlink" title="CASE工具的控制集成"></a>CASE工具的控制集成</h5><ul><li>控制集成支持工作台或环境中一个工具对系统中其它工具的访问</li><li>控制集成的目的是为了让工具共享功能</li><li>工具之间的控制关系包括：<ol><li>供给：一个工具被别的工具使用</li><li>使用：一个工具使用其他工具</li></ol></li></ul><h5 id="CASE的过程集成"><a href="#CASE的过程集成" class="headerlink" title="CASE的过程集成"></a>CASE的过程集成</h5><ul><li><p>过程是指开发软件所需要的阶段、任务活动序列，许多工具都服务于一定过程</p></li><li><p>过程集成是指CASE系统嵌入了关于过程活动、阶段、约束和支持这些活动所需要的工具的知识</p></li><li><p>过程集成属性包括：</p><ol><li>构成块</li><li>事件</li><li>约束</li></ol></li><li><p>如：vs</p><img src="https://blogpicture01.oss-cn-beijing.aliyuncs.com/img/image-20220301152150468.png" style="zoom:50%;"></li></ul><h3 id="1-3软件开发环境简介："><a href="#1-3软件开发环境简介：" class="headerlink" title="1.3软件开发环境简介："></a>1.3软件开发环境简介：</h3><ul><li>软件开发环境的发展</li><li>软件开发环境的要求</li><li>软件开发环境的特性</li><li>软件开发环境的分类</li></ul><p><strong><u>软件开发环境</u>是指在计算机的基础软件（比如操作系统）上，为了支持软件的开发而提供的一组工具软件系统</strong></p><h4 id="1-3-1软件开发环境的组成"><a href="#1-3-1软件开发环境的组成" class="headerlink" title="1.3.1软件开发环境的组成"></a>1.3.1软件开发环境的组成</h4><ol><li>人机接口 ——软件工具环境的重要质量标志</li><li>软件环境数据库—— 软件开发环境的核心</li><li>软件开发工具——完成具体的工作</li></ol><h4 id="1-3-2软件开发环境的数据库组成"><a href="#1-3-2软件开发环境的数据库组成" class="headerlink" title="1.3.2软件开发环境的数据库组成"></a>1.3.2软件开发环境的数据库组成</h4><ol><li>通用子程序数据库（比如函数库）</li><li>可重组的程序加工信息库（编译环境）</li><li>模块描述与接口信息库（接口，.h文件）</li><li>软件测试与纠错依据信息库（调试信息）</li><li>可行性和需求信息档案（需求文档）</li><li>阶段设计详细档案（设计文档）</li><li>测试驱动数据库（测试案例）</li><li>软件维护档案等（维护文档）</li></ol><p>示例：</p><img src="https://blogpicture01.oss-cn-beijing.aliyuncs.com/img/image-20220301154646824.png" style="zoom:50%;"><h4 id="1-3-3软件开发环境的分层"><a href="#1-3-3软件开发环境的分层" class="headerlink" title="1.3.3软件开发环境的分层"></a>1.3.3软件开发环境的分层</h4><p><strong>通常分为以下四层：</strong></p><ol><li>宿主层</li><li>核心层</li><li>基本层</li><li>应用层</li></ol><h5 id="宿主层："><a href="#宿主层：" class="headerlink" title="宿主层："></a>宿主层：</h5><p>宿主层是软件开发环境依赖的计算机基础，包括：</p><ol><li>基本宿主硬件，如计算机、工作站、服务器等</li><li>基本宿主软件，如操作系统</li></ol><h5 id="核心层："><a href="#核心层：" class="headerlink" title="核心层："></a>核心层：</h5><p>核心层是软件开发环境本身的支持基础，比如：</p><img src="https://blogpicture01.oss-cn-beijing.aliyuncs.com/img/image-20220301155909076.png" style="zoom:50%;"><ol><li>C#的CLR( Common Language Runtime)</li><li>Java的虚拟机JVM等</li></ol><h5 id="基本层："><a href="#基本层：" class="headerlink" title="基本层："></a>基本层：</h5><ul><li>基本层是软件开发工具的工作工具集，包括</li><li>最少限度的一组工具，比如：<ol><li>编译工具</li><li>连接工具</li><li>调试工具等</li></ol></li><li>这些工具由核心层支持</li></ul><h5 id="应用层："><a href="#应用层：" class="headerlink" title="应用层："></a>应用层：</h5><p>应用层是以特定的基本层为基础而引入的配套补充工具，比如：</p><img src="https://blogpicture01.oss-cn-beijing.aliyuncs.com/img/image-20220301155836294.png" style="zoom:67%;"><ol><li>界面生成器</li><li>版本管理器</li><li>性能分析器等</li></ol><h4 id="1-3-4软件开发环境的发展"><a href="#1-3-4软件开发环境的发展" class="headerlink" title="1.3.4软件开发环境的发展"></a>1.3.4软件开发环境的发展</h4><p>软件开发环境的发展依赖于软件开发方法的发展</p><ul><li>20世纪70年代：结构化开发方法，主要是<strong>高级语言开发工具</strong>的发展</li><li>20世纪80年代：面向对象方法，主要是<strong>面向对象开发工具</strong>的发展</li><li>20世纪90年代：系统集成方法，CASE<strong>集成开发环境</strong>开始出现</li></ul><h5 id="结构化的开发方法和工具"><a href="#结构化的开发方法和工具" class="headerlink" title="结构化的开发方法和工具"></a>结构化的开发方法和工具</h5><ul><li>20世纪70年代：结构化开发方法，主要是结构化高级语言开发工具的发展</li><li>结构化程序设计方法又称为“自顶向下”或“逐步求精”法</li></ul><p><strong>结构化程序设计方法是按照模块划分原则以提高程序可读性和易维护性、可调性和可扩充性为目标的一种程序设计方法。</strong></p><p>在结构化的程序设计中，只允许三种基本的程序结构形式：</p><ol><li>顺序结构</li><li>分支结构</li><li>循环结构</li></ol><p><strong>这三种基本结构的共同特点是只允许有一个流动入口和一个出口，仅有这三种基本结构组成的程序称为<u>结构化程序</u></strong></p><h5 id="面向对象开发方法和工具："><a href="#面向对象开发方法和工具：" class="headerlink" title="面向对象开发方法和工具："></a>面向对象开发方法和工具：</h5><ul><li>20世纪80年代：面向对象方法，主要是面向对象开发工具的发展</li><li>面向对象编程的基础是类，三大机制： “封装、继承、多态”</li></ul><p>面向对象程序设计（Object Oriented Programming，OOP）是一种计算机编程架构。</p><img src="https://blogpicture01.oss-cn-beijing.aliyuncs.com/img/image-20220301161046444.png" alt="image-20220301161046444" style="zoom:50%;"><p><strong>OOP的一条基本原则是计算机程序由单个能够起到子程序作用的单元或对象组合而成。</strong></p><p>OOP达到了软件工程的三个主要目标：重用性、灵活性和扩展性。</p><p>OOP&#x3D;对象+类+继承+多态+消息，其中核心概念是类和对象。</p><h5 id="集成化开发方法和工具："><a href="#集成化开发方法和工具：" class="headerlink" title="集成化开发方法和工具："></a>集成化开发方法和工具：</h5><ul><li>20世纪90年代：系统集成方法，CASE集成开发环境开始出现</li></ul><img src="https://blogpicture01.oss-cn-beijing.aliyuncs.com/img/image-20220301161425599.png" style="zoom:50%;"><h4 id="1-3-5软件开发环境的要求"><a href="#1-3-5软件开发环境的要求" class="headerlink" title="1.3.5软件开发环境的要求"></a>1.3.5软件开发环境的要求</h4><ol><li>高度集成化的系统</li><li>具有高度的通用性</li><li>易于定制，具有高度的适应性和灵活性</li><li>具有易用性</li><li>具有半自动或自动化的开发能力</li></ol><h5 id="高度集成化的系统"><a href="#高度集成化的系统" class="headerlink" title="高度集成化的系统"></a>高度集成化的系统</h5><p><strong>支持软件生存周期各个阶段的活动，包括：需求分析、系统设计、编码、调试以及维护等</strong></p><ul><li>支持软件生存周期各个阶段的管理和开发两方面的工作</li><li>协调一致地支持各阶段和各方面的工作，具有统一的内部数据表示</li><li>具有一致性的用户接口</li></ul><img src="https://blogpicture01.oss-cn-beijing.aliyuncs.com/img/image-20220301161823472.png" style="zoom:50%;"><h5 id="高度的通用性："><a href="#高度的通用性：" class="headerlink" title="高度的通用性："></a>高度的通用性：</h5><ol><li>能适应最常用的几种语言</li><li>能适应和支持不同的开发方法</li><li>能适应不同的计算机硬件及其系统软件</li><li>能适应开发不同类型的软件</li><li>能适应并考虑到不同用户的需要（如程序员、系统分析员、项目经理、质量保证人员等）</li></ol><img src="https://blogpicture01.oss-cn-beijing.aliyuncs.com/img/image-20220301161951991.png" style="zoom:50%;"><h5 id="易于定制，裁剪和扩充"><a href="#易于定制，裁剪和扩充" class="headerlink" title="易于定制，裁剪和扩充"></a>易于定制，裁剪和扩充</h5><ul><li>定制是指软件开发环境应能符合项目特征、过程和用户的爱好</li><li>裁剪是指环境能按照用户需求建立好子环境</li><li>扩充是指环境能向上扩展，能根据用户新的需求或软件技术的新发展对原有的环境进行更新或扩充（Eclipse插件）</li></ul><h5 id="易学易用，经济高效"><a href="#易学易用，经济高效" class="headerlink" title="易学易用，经济高效"></a>易学易用，经济高效</h5><ul><li>易学、易用、响应时间合理和用户喜爱</li><li>能支持自然语言处理</li><li>能支持交互式和分布式软件开发</li><li>降低用户和环境的资源花费</li></ul><h5 id="具有半自动或自动化能力"><a href="#具有半自动或自动化能力" class="headerlink" title="具有半自动或自动化能力"></a>具有半自动或自动化能力</h5><ul><li>各个阶段的文档之间要能半自动或自动地变换和跟踪（Rational Rose UML)</li><li>应注重使用形式化技术</li><li>不同程度地、逐步采用“软件构件”的集成组装技术，并建立软件构件库</li><li>采用人工智能技术，逐步包含支持软件开发的专家系统</li></ul><h4 id="1-3-6软件开发环境的特性"><a href="#1-3-6软件开发环境的特性" class="headerlink" title="1.3.6软件开发环境的特性"></a>1.3.6软件开发环境的特性</h4><p>软件开发环境的特性包括：</p><ul><li>可用性</li><li>自动化程度</li><li>公共性</li><li>集成化程度</li><li>适应性</li></ul><h5 id="软件开发环境的分类："><a href="#软件开发环境的分类：" class="headerlink" title="软件开发环境的分类："></a>软件开发环境的分类：</h5><p>软件开发环境与软件生存期、软件开发方法、软件处理模型紧密相关，有多种分类方法：</p><ul><li>按问题分类</li><li>按软件开发环境的演变趋势分类</li><li>按集成化程度分类</li></ul><h5 id="按照问题分类："><a href="#按照问题分类：" class="headerlink" title="按照问题分类："></a>按照问题分类：</h5><h6 id="程序设计环境："><a href="#程序设计环境：" class="headerlink" title="程序设计环境："></a>程序设计环境：</h6><p>解决如何将规范说明（软件需求规格说明书）转换成可工作的程序（代码和运行程序）的问题，包括两个部分：方法和工具</p><img src="https://blogpicture01.oss-cn-beijing.aliyuncs.com/img/image-20220301163206591.png" alt="image-20220301163206591" style="zoom:67%;"><h6 id="系统合成环境-："><a href="#系统合成环境-：" class="headerlink" title="系统合成环境 ："></a>系统合成环境 ：</h6><p><strong>主要考虑把很多子系统集成为一个大系统的问题</strong></p><p>所有大型软件都有两个基本特点：</p><ol><li>由一些小的、较易理解的子系统组成</li><li>需要有一个系统合成环境来辅助控制系统及其向大系统的集成（基于组件的开发）</li></ol><p>如：原生插件调用</p><ul><li><p>二维码扫描</p></li><li><p>地理定位</p></li><li><p>摄像头拍照及录像</p></li><li><p>音频录制及播放</p></li><li><p>微信支付、支付宝支</p><img src="https://blogpicture01.oss-cn-beijing.aliyuncs.com/img/image-20220301163426274.png" alt="image-20220301163426274" style="zoom:50%;"></li></ul><h6 id="项目管理环境："><a href="#项目管理环境：" class="headerlink" title="项目管理环境："></a>项目管理环境：</h6><ul><li>大型软件系统的开发和维护必然会有很多人员在同一时间段内协同工作，需要对人与人之间的交流和合作进行管理</li><li>项目管理环境 的责任是解决由于软件产品的规模大、生存期长、人们的交往多而造成的问题</li></ul><p><img src="https://blogpicture01.oss-cn-beijing.aliyuncs.com/img/image-20220301163641467.png" alt="image-20220301163641467"></p><h3 id="1-4总结："><a href="#1-4总结：" class="headerlink" title="1.4总结："></a>1.4总结：</h3><p><strong>软件开发工具、环境和CASE之间的关系</strong></p><ul><li>工具是一款具体的开发软件</li><li>CASE是计算机软件工程的辅助工具</li><li>环境是开发工具的集合</li></ul><p>工具学习流程： 了解+掌握+应用</p><img src="https://blogpicture01.oss-cn-beijing.aliyuncs.com/img/image-20220301164114766.png" alt="image-20220301164114766" style="zoom:50%;">]]></content>
      
      
      <categories>
          
          <category> 软件开发环境与工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>introduction to software engineer</title>
      <link href="/2022/02/28/introduction%20to%20software%20engineer/"/>
      <url>/2022/02/28/introduction%20to%20software%20engineer/</url>
      
        <content type="html"><![CDATA[<h1 id="introduction-to-software-engineer"><a href="#introduction-to-software-engineer" class="headerlink" title="introduction to software engineer"></a>introduction to software engineer</h1><h2 id="1-Software-and-Software-Engineering"><a href="#1-Software-and-Software-Engineering" class="headerlink" title="1.Software and Software Engineering"></a>1.Software and Software Engineering</h2><h3 id="1-1The-Nature-of-Software"><a href="#1-1The-Nature-of-Software" class="headerlink" title="1.1The Nature of Software"></a>1.1The Nature of Software</h3><h4 id="defining-software"><a href="#defining-software" class="headerlink" title="defining software"></a>defining software</h4><p>software is :</p><ol><li>instructions that when executed provide desired features, function and performance</li><li>data structures that enable the programs to adequately manipulate information</li><li>descriptive information in both hard copy and virtual forms that describes the operation and use of the program</li></ol><p><strong>software has one fundamental characteristics that makes it considerably different from hardware: <u>software doesn’t wear out</u></strong></p><p><strong>bathtub curve</strong></p><h4 id="software-Application-Domain"><a href="#software-Application-Domain" class="headerlink" title="software Application Domain"></a>software Application Domain</h4><ul><li>System software</li><li>Application software</li><li>Engineering&#x2F;scientific software</li><li>Embedded software</li><li>Product-line software</li><li>Web&#x2F;mobile applications</li><li>artificial intelligence software</li></ul><h4 id="The-legacy-Software"><a href="#The-legacy-Software" class="headerlink" title="The legacy Software"></a>The legacy Software</h4><p>The legacy software can be described in the following way:</p><p><strong>Legacy software systems were developed decades ago and have been continually modified to meet changes in business requirements and computing platforms</strong></p><p><strong>The proliferation of such systems is causing headaches for large organizations who find them costly to maintain and risky to evolve</strong></p><p>The reason for the legacy software to be fixed only include:</p><ul><li>The software must be adapted to meet the needs of new computing environments of technology</li><li>The software must be enhanced tp implement new business requirements</li><li>The software must be enhanced to make it work with other more modern systems of databases</li><li>The software must be re-architected to make it viable within an evolving computing environment</li></ul><h3 id="1-2"><a href="#1-2" class="headerlink" title="1.2"></a>1.2</h3><h2 id="2-Process-model"><a href="#2-Process-model" class="headerlink" title="2.Process model"></a>2.Process model</h2><h3 id="2-0Preview"><a href="#2-0Preview" class="headerlink" title="2.0Preview"></a>2.0Preview</h3><p><strong>“Software Process”</strong> Definition: A series of predictable steps (a road map) that helps you deliver a high-quality product on time</p><p>A process providers stability, control, and organization to an activity so that it does not become chaotic</p><p>The process that you adopt depends on the software that you are building.</p><h4 id="2-0-1Software-process-model"><a href="#2-0-1Software-process-model" class="headerlink" title="2.0.1Software process model"></a>2.0.1<strong>Software process model</strong></h4><ul><li>Attempt to organize the software cycle by <ul><li>defining activities involved in software production</li><li>order of activities and their reationships</li></ul></li><li>Goals of a sofeware process<ul><li>standardization</li><li>predictability</li><li>productivity</li><li>high product quality</li><li>ability to plan time and budget requirements</li></ul></li></ul><h4 id="2-0-2The-reason-for-models"><a href="#2-0-2The-reason-for-models" class="headerlink" title="2.0.2The reason for models:"></a>2.0.2<strong>The reason for models:</strong></h4><ul><li>Software crisis<ul><li>scheduled time and cost exceeded</li><li>user expectations not met</li><li>poor quality</li></ul></li><li>The size and economic value of software applications required appropriate “<u>process models</u>“</li></ul><h4 id="2-0-3Problems"><a href="#2-0-3Problems" class="headerlink" title="2.0.3Problems"></a>2.0.3Problems</h4><ul><li>The assumptions is that requirements can be fully understood prior to development</li><li>Interaction with the customer occurs only at the beginning(requirements) and end(after delivery)</li></ul><p><strong><u>Unfortunately the assumption almost never holds</u></strong></p><h4 id="2-0-4Advantages"><a href="#2-0-4Advantages" class="headerlink" title="2.0.4Advantages"></a>2.0.4Advantages</h4><ul><li>Reduce risks by improving visibility</li><li>Allow project changes as the project progresses</li><li>The changes based on feedback from the customer</li></ul><h3 id="2-1-A-generic-process-model"><a href="#2-1-A-generic-process-model" class="headerlink" title="2.1 A generic process model"></a>2.1 A generic process model</h3><h4 id="2-1-1-Process-define"><a href="#2-1-1-Process-define" class="headerlink" title="2.1.1 Process define"></a>2.1.1 Process define</h4><p>**A process was defined as a collection of activities, actions, and tasks that are performed when some product is to be created. **</p><p><strong>Each of the activities, actions, and tasks resides within <u>a framework or model that defines their relationship with the process and with another</u>.</strong></p><p>Each framework activity is populated by a set of software engineering actions</p><p>Each software engineering action is defined by a task set that identifies the work tasks that are to be completed.</p><img src="https://blogpicture01.oss-cn-beijing.aliyuncs.com/img/image-20220307143810330.png" style="zoom:50%;"><p><strong>A generic process framework for software engineering defines five framework activities:</strong></p><ul><li>communication</li><li>planning </li><li>modeling</li><li>construction</li><li>deployment</li></ul><img src="https://blogpicture01.oss-cn-beijing.aliyuncs.com/img/image-20220307144011382.png" style="zoom:50%;"><h4 id="2-1-2Process-flow"><a href="#2-1-2Process-flow" class="headerlink" title="2.1.2Process flow:"></a>2.1.2<strong>Process flow:</strong></h4><p><strong>Linear flow:</strong></p><p>A linear process flow executes each of the five framework activities in sequence</p><p><img src="https://img-blog.csdnimg.cn/img_convert/f44a28c6aec3a047b5eb880024c6295e.png" alt="img"></p><p><strong>Iterative process flow:</strong></p><p>May repeats one or more of the activities before proceeding to the next</p><img src="https://img-blog.csdnimg.cn/img_convert/cf11e9dccd3c25263b98f6860b214ff0.png" alt="img" style="zoom: 67%;"><p><strong>Evolutionary process flow:</strong></p><p> This executes the activities in a “circular” manner, each circuit through the five activities leads to a more complete version of the software.</p><img src="https://img-blog.csdnimg.cn/img_convert/a8a7615a48f0b6c8d54eb3fbb47fa786.png" alt="img" style="zoom: 67%;"><p><strong>Parallel process flow:</strong></p><p>This executes one or more activities in parallel with other activities(modeling for one aspect of the software might be executed in parallel with construction of another aspect of the software)</p><img src="https://img-blog.csdnimg.cn/img_convert/6417d23c758a1c60a5a4a40beb8c179f.png" alt="img" style="zoom: 67%;"><h3 id="2-2Prescriptive-process-model"><a href="#2-2Prescriptive-process-model" class="headerlink" title="2.2Prescriptive process model"></a>2.2Prescriptive process model</h3><p>Prescriptive process models define a predefined set of process elements and a predictable process work flow</p><h3 id="2-2-1The-waterfall-model"><a href="#2-2-1The-waterfall-model" class="headerlink" title="2.2.1The waterfall model"></a>2.2.1The waterfall model</h3><p>The waterfall model, sometimes called the “linear sequential model”, suggests a systematic, sequential approach to software development </p>]]></content>
      
      
      <categories>
          
          <category> introduction to software engineer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>computer network(chapter 1)-1</title>
      <link href="/2022/02/24/computer-network(chapter1)/"/>
      <url>/2022/02/24/computer-network(chapter1)/</url>
      
        <content type="html"><![CDATA[<h1 id="computer-network-chapter-1-1"><a href="#computer-network-chapter-1-1" class="headerlink" title="computer network(chapter 1)-1"></a>computer network(chapter 1)-1</h1><h2 id="preview"><a href="#preview" class="headerlink" title="preview"></a>preview</h2><h3 id="Internet"><a href="#Internet" class="headerlink" title="Internet"></a>Internet</h3><ul><li>Internet: “network of networks” Interconnected ISPs</li><li>protocols: control sending , receiving of message. TCP,IP,HTTP,Skype</li><li>Internet standards:<ul><li>RFC: Request for comments</li><li>IETF: Internet Engineering task force</li></ul></li><li>Internet: a serve view<ul><li>infrastructure that provides services to applications: Web,VoIP,email,games,ecommerce,social nets</li></ul></li></ul><h3 id="Protocol"><a href="#Protocol" class="headerlink" title="Protocol"></a>Protocol</h3><p>protocol define format, order of message sent and received among network entities , and actions taken on message transmission ,receipt</p><h2 id="1-1network-structure"><a href="#1-1network-structure" class="headerlink" title="1.1network structure"></a>1.1network structure</h2><ul><li><p>network edge: </p><ul><li>hosts: clients and servers </li><li>servers often in data centers</li></ul></li><li><p>access networks,physical media:</p><p>wired,wireless,communication links</p></li><li><p>network core :</p><ul><li>interconnected routers</li><li>network of networks</li></ul></li></ul><h2 id="1-2network-edge"><a href="#1-2network-edge" class="headerlink" title="1.2network edge"></a>1.2network edge</h2><h3 id="ISP-internet-service-provider"><a href="#ISP-internet-service-provider" class="headerlink" title="ISP(internet service provider)"></a>ISP(internet service provider)</h3><p>End system access the Internet through ISP, such as local cable or telephone companies</p><h3 id="Access-networks"><a href="#Access-networks" class="headerlink" title="Access networks"></a>Access networks</h3><ul><li>serveral connect methods<ul><li>ressidential access nets</li><li>institutional nets wnetworks</li><li>mobile access networks</li></ul></li></ul><ol><li><p><strong>DSL(digitl subscriber line)</strong></p><ul><li>use existing telephone line to central office DSLAM<ul><li>data over DSL phone line goes to internet</li><li>voice over DSL phone line goes to telephone net</li></ul></li><li><u>&lt;2.5Mbps Upstream rtansmission rate (typically &lt; 1Mbps)</u></li><li><u>&lt;24Mbps downstream transmission rate (typically &lt; 10Mbps)</u></li></ul></li><li><p>Cable network</p><p>frequency division multiplexing : different channels transmitted in different frequency bands</p><ul><li><p>HFC: hybrid fiber coax</p><p>asymmetric network: <u>30Mbps downstream transmission rate, 2Mbps upstream transmission rate</u></p></li><li><p>network of cable,fiber attaches homes to ISP router</p><ul><li>home share access network to cable headend</li><li>unlike DSL, which has dedicated access to central office</li></ul></li></ul></li><li><p>home network: various devices </p></li><li><p>Ethernet (Enterprise access networks)</p><ul><li>typically used in companies,universities etc.</li><li>10Mbps,100Mbps,1Gbps,10Gbps transmission rates</li><li>today,end system typcally connect into Ethernet switch</li></ul></li><li><p>wireless access networks</p><ul><li>shared wireless access network connects end system to router : via base station aka “access point”</li><li><u>Wireless LANs</u><ol><li>within building (100ft.)</li><li>wifi: 1,54,450Mbps transimission rate</li></ol></li><li><u>wide area wireless access</u><ol><li>provided by telco(cellular) operator</li><li>between 1 and 10Mbps</li><li>3G,4G:LTE</li></ol></li></ul></li></ol><h3 id="sending-message"><a href="#sending-message" class="headerlink" title="sending message"></a>sending message</h3><p>link transmission rate, aka link capacity , aka link bandwidth</p><p>packet transmission delay &#x3D; L(bits)&#x2F;R(bits&#x2F;sec)</p><h3 id="Physical-media"><a href="#Physical-media" class="headerlink" title="Physical media"></a>Physical media</h3><ul><li><p>bit: propagates between transmitter&#x2F;receiver pairs</p></li><li><p>physical link: what lies between transmitter&amp;receiver</p></li><li><p>guide media: </p><p>signals propagate in solid media: copper,fiber,coax</p></li><li><p>unguided media</p><p>signals propagate freely,ratio</p></li><li><p>Twisted pair(TP)</p><p>two insulated copper wires</p><p>category5: 100Mbps,1Gbps Ethernet</p><p>category6: 10Gbps</p></li><li><p><u>coaxial cable</u></p><ul><li>two concentric copper conductors</li><li>bidirectional</li><li>broadband<ul><li>Mutiple channels on cable</li><li>HFC</li></ul></li></ul></li><li><p>fiber optic cable</p><ul><li>glass fiber carrying light pulses , each pulse a bit</li><li>high-speed operation: high-speed point-to-point ransmission(10’s-100’sGbps transmission rate)</li></ul></li><li><p>lowrer error rate</p><ul><li>repeaters spaced far apart </li><li>immune to electronmagnetic noise</li></ul></li><li><p>radio</p><ul><li><p>no phsical “wire”  bidirectional </p></li><li><p>radio link types:</p><ol><li><p>terrestrial microwave </p><p>up to 45Mbps channels</p></li><li><p>LAN(wifi)</p><p>54Mbps</p></li><li><p>wide area</p><p>4G cellular:~10 Mbps</p></li><li><p>satellite</p><ul><li>Kbps to 45Mbps channel(or mutiple smaller channels)</li><li>270 msec end-to-end delays</li><li>geosynchronous versus low altitude</li></ul></li></ol></li></ul></li></ul><h2 id="1-3network-core"><a href="#1-3network-core" class="headerlink" title="1.3network core"></a>1.3network core</h2><ul><li>mesh of interconnected router</li><li>packet-switching: hosts break application-layer message into packets<ul><li>forward packets form one router to the next ,across links on path from source to destination</li><li>each packet transmitted at full link capacity</li></ul></li></ul><h3 id="Packet-switch-store-and-forward"><a href="#Packet-switch-store-and-forward" class="headerlink" title="Packet-switch: store-and-forward"></a>Packet-switch: store-and-forward</h3><ul><li>It takes L&#x2F;R seconds to transmit L-bit packet into link at R bps</li><li>store and forward: entire packet must arrive at router before it can be transmitted on next link</li><li>end-end delay &#x3D;2L&#x2F;R(assuming zero propagation delay)</li></ul><h3 id="Packet-switching-queueing-delaying-loss"><a href="#Packet-switching-queueing-delaying-loss" class="headerlink" title="Packet-switching: queueing delaying,loss"></a>Packet-switching: queueing delaying,loss</h3><p>if arrival rate(in bits)to link exceeds transmission rate of link for a period of time:</p><ul><li>packets will queue, wait to be transimitted on link </li><li>packets can be dropped(lost) if memory(buffers) fills up</li></ul><h3 id="Tow-key-network-core-functions"><a href="#Tow-key-network-core-functions" class="headerlink" title="Tow key network-core functions"></a>Tow key network-core functions</h3><ul><li>routing: determines source-destination route taken by packets</li><li>forwarding: move packets from router’ input to appropriate router ouput</li></ul><h3 id="Alternative-core-circuit-switching"><a href="#Alternative-core-circuit-switching" class="headerlink" title="Alternative core: circuit switching"></a>Alternative core: circuit switching</h3><p>end-end resources allocated to,reserved for “call” between source&amp;destination</p><ul><li><p>in diagram, each links has four circuits </p><p>call gets 2nd circuit in top link and 1st circuit in right link</p></li><li><p>dedicated resources: no sharing</p><p>circuit-like(guaranteed) performance</p></li><li><p>circuit segment idle if not used by call(no sharing)</p></li><li><p>commonly used in traditional telephone networks</p></li></ul><h3 id="FDM-versus-TDM"><a href="#FDM-versus-TDM" class="headerlink" title="FDM versus TDM"></a>FDM versus TDM</h3><p>FDM: frequency-division multiplexing</p><p>TDM: time-division multiplexing</p><ul><li>With FDM each circuit continuously gets a fraction of the bandwidth</li><li>With TDM each circuit gets all of the bandwidth periodically during brief of time</li></ul><h3 id="Packet-switching-versus-circuit-switching"><a href="#Packet-switching-versus-circuit-switching" class="headerlink" title="Packet switching versus circuit switching"></a>Packet switching versus circuit switching</h3><ul><li><p>Packet switching </p><p>Advantages:</p><ul><li>great for bursty data</li><li>resource sharing</li><li>simpler, no call set up</li></ul><p>excessive congestion possible: </p><ul><li>packet delay and loss</li><li>protocols needed for reliable data transfer, congestion control</li></ul></li><li><p>circuit switching </p><ul><li>bandwidth guarantees needed for audio&#x2F;video apps</li><li>still an unsolved problem(chapter 7)</li></ul></li></ul><h3 id="Internet-structure-network-of-neworks"><a href="#Internet-structure-network-of-neworks" class="headerlink" title="Internet structure: network of neworks"></a>Internet structure: network of neworks</h3><ul><li>End-system connect to the access ISP</li><li>access ISP connect to the regional ISP </li><li>regional access connect to tier ISP</li></ul><h2 id="1-4Delay-loss-and-throughput-in-packet-switched-Networks"><a href="#1-4Delay-loss-and-throughput-in-packet-switched-Networks" class="headerlink" title="1.4Delay,loss,and throughput in packet-switched Networks"></a>1.4Delay,loss,and throughput in packet-switched Networks</h2><h3 id="Delay"><a href="#Delay" class="headerlink" title="Delay:"></a>Delay:</h3><img src="https://blogpicture01.oss-cn-beijing.aliyuncs.com/img/image-20220228233531690.png" style="zoom:50%;"><ul><li><p>Processing delay (<u>this relates to router’s cycle of instruction</u>) (constant)</p><p>The time required to examine the packet’s header and determine where to direct the part</p><p>Processing delays in high-speed routers are typically on the order of microseconds or less</p><p><u>After this nodal processing, the router directs the packet to the queue that precedes the links to router B</u> </p></li><li><p>Queuing delay (variable)</p><p>The time it waits to be transmitted onto the link.</p><p>This can be on the order of microseconds to milliseconds in practice</p></li><li><p>Transmission delay (constant)</p><p>This can be different in various way </p><p>Typically , the first-come-first-served manner, the delay formula is</p><p><strong>D(delay)&#x3D;L(Packet length)&#x2F;R(link bandwidth)</strong></p><p>Transmission delays are typically on the order of microseconds to milliseconds in practice</p></li><li><p>Propagation delay (constant)</p><p>The time required to propagate from the beginning of the link to router B </p><p>This propagation speed is the range of </p><p><strong>2<em>10^8 meter&#x2F;sec to 3</em>10^8 meters&#x2F;sec</strong></p><p>The formula is</p><p><strong>D(delay)&#x3D;d(length of physical link)&#x2F;s(propagation speed)</strong></p></li></ul><p><strong>link : the device transform the digital signal to the analog signal</strong></p><p><strong>relay device: the intermedium device transmit the analog signal</strong>  </p><h3 id="Queuing-delay-and-packet-loss"><a href="#Queuing-delay-and-packet-loss" class="headerlink" title="Queuing delay and packet loss"></a>Queuing delay and packet loss</h3><ul><li><p>Queuing delay:</p><p>traffic intensity: terminology to describe the congestion of the queue</p><p>The fofmula:</p><p><strong>Traffic intensity &#x3D; L*a&#x2F;R</strong></p><p>L:Per packet consists of L bits data</p><p>a:Average rate of link packets arrive the queue (packets&#x2F;sec)</p><p>R:The rate at witch bits are pushed out the queue (bits&#x2F;sec)</p></li></ul><img src="https://blogpicture01.oss-cn-beijing.aliyuncs.com/img/image-20220228233646419.png" alt="image-20220228233646419" style="zoom:50%;"><ul><li><p>Packet loss</p><p>Queue preceding link n buffer has finite capacity</p><p>packet arriving to full queue dropped </p><p>lost packet may be retransmitted by previous node, by source end system, or not at all</p></li></ul><h3 id="Throughput"><a href="#Throughput" class="headerlink" title="Throughput"></a>Throughput</h3><p>The rate(bits&#x2F;time unit) at witch bits transferred between sender and receiver</p><ul><li><p>instantaneous: rate at given point in time</p></li><li><p>average: rate over longer period of time</p></li><li><p>The formula for throughput</p><p><strong>The bottleneck link: The minimal transmission rate of witch router has in the entire network</strong></p><ul><li>throughput &#x3D; min{Rs,Rc} only client and server</li><li>throughut &#x3D; min {R1,R2,…,Rn,Rs,Rc} include other routers</li><li>throughput &#x3D; min{R1,R2,…,Rn,Rs,Rc,R(<u>bottleneck&#x2F;users</u>)} multiple users sharing one network</li></ul></li></ul><img src="https://blogpicture01.oss-cn-beijing.aliyuncs.com/img/image-20220228233249932.png" style="zoom:50%;"><h2 id="1-5Protocol-layers-service-models"><a href="#1-5Protocol-layers-service-models" class="headerlink" title="1.5Protocol layers, service models"></a>1.5Protocol layers, service models</h2><h3 id="Layers"><a href="#Layers" class="headerlink" title="Layers:"></a>Layers:</h3><p> Each layer implements a service</p><ul><li>via its own internal-layer actions</li><li>relying on services provides by layer below</li></ul><p>dealing with complex systems:</p><ul><li>explicit structure allows identification, relationship of complex system’s pieces<ul><li>layered reference model for discussion</li></ul></li><li>modularization eases maintenance, updating of system<ul><li>change of implementation of layers’ service transparent to rest of system</li><li>change in gate procedure doesn’t affect rest of system</li></ul></li></ul><p><strong>Internet protocol stack</strong> (From bottom to top)</p><ul><li><p>Application: supporting network applications</p><p>FTP,SMTP,HTTP</p></li><li><p>Transport: process-process data transfer</p><p>TCP(typical),UDP(no-frills)</p></li><li><p>Network: the routing of datagrams from source to destination</p><p>IP,routing protocol</p></li><li><p>link: data transfer between neighboring network elements</p><p>Ethernet,Wifi,PPP</p></li><li><p>physical: bits “on the wire”</p></li></ul><img src="https://blogpicture01.oss-cn-beijing.aliyuncs.com/img/image-20220228231507652.png" style="zoom: 33%;"><p><strong>IOS&#x2F;OSI reference model</strong></p><img src="https://blogpicture01.oss-cn-beijing.aliyuncs.com/img/image-20220301205238242.png" alt="image-20220301205238242" style="zoom:50%;"><ul><li>presentation: allow applications to interpret meaning of data, encryption, compression, machine-specific conventions</li><li>session: synchronization, checkpointing, recovery of data exchange</li></ul><p><strong>Internet stack “missing” these layers!</strong></p><p>these services, if needed, must be implemented in application</p><h3 id="Encapsulation"><a href="#Encapsulation" class="headerlink" title="Encapsulation:"></a>Encapsulation:</h3><ul><li>Application: append message</li><li>transport: append segment</li><li>network: append datagram</li><li>link: append frame</li></ul><img src="https://blogpicture01.oss-cn-beijing.aliyuncs.com/img/image-20220228231927492.png" style="zoom: 50%;"><p>Typically, switch only has link and physical layers, no network layer ,witch means it doesn’t have IP address and cannot be found by uesers </p><p><strong>PDU: Each layer in protocol stack, except layer-1(physical), has its PDU(protocol data unit)</strong></p><p><strong>Data + header &#x3D; PDU</strong></p><img src="https://blogpicture01.oss-cn-beijing.aliyuncs.com/img/image-20220228232827461.png" style="zoom: 50%;"><img src="https://blogpicture01.oss-cn-beijing.aliyuncs.com/img/image-20220301211157835.png" alt="image-20220301211157835" style="zoom:50%;"><ul><li>Application-layer-<strong>message</strong>: Exchange of packet information</li><li>Transport-layer-<strong>segment</strong>: Appending <strong><u>additional information</u></strong>(so-called transport-layer header information, the added information may include information allowing the receiver-side transport layer to deliver the message up to the appropriate application, and error detection bits which show whether the message have been changed), which will be used by the receiver-side transport-layer, <strong><u>the message and header comprise of segment</u></strong></li><li>Network-layer-<strong>datagram</strong>: Appending network-layer header, such as source and destination end system address, creating a <strong><u>datagram</u></strong></li><li>Link-layer-frame: appending linked-layer header</li><li>Each packet has two type of fields: header and payload(A packet form the layer above)</li></ul><h2 id="The-homework-complements-（extension-and-correct）"><a href="#The-homework-complements-（extension-and-correct）" class="headerlink" title="The homework complements （extension and correct）"></a>The homework complements （extension and correct）</h2><ul><li>NAT(Network Address Transmission)</li><li>A router equipped with NAT software is called a NAT router and has at least one valid external global IP address (public IP address)</li><li>Host &#x3D; end system; end system &#x3D; clients + server (page 11)</li><li>Two nodes in the internet are connected together by communication links</li><li>socket: A interface that specifies how a program running on one end system asks the internet infrastructure to deliver data to a specific destination program running on other end system</li><li>FDDI(Fiber Distributed Data Interface): typically used in area network(campus network)</li><li>Two types of packet-switch network: datagram networks and virtual-circuit networks<ul><li>virtual-circuit: no destination code, just have a virtual code(int, witch points the next Router), then, a virtual circuit are constructed, the transmission direction has been fixed.</li></ul></li><li>There is no congestion in a circuit switching network</li><li>The drawbacks of message segmentation(packet-switch): <ul><li>Packets have to be put in sequence at the destination </li><li>Message segmentation results in many smaller packets. Since header size is usually the same for all packets regardless of their size, with message segmentation the total amount of header bytes is more</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> computer network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>servelet学习</title>
      <link href="/2022/02/23/servelet/"/>
      <url>/2022/02/23/servelet/</url>
      
        <content type="html"><![CDATA[<h1 id="javaweb"><a href="#javaweb" class="headerlink" title="javaweb"></a>javaweb</h1><p>Tomcat: web 应用服务器</p><h2 id="servlet"><a href="#servlet" class="headerlink" title="servlet"></a>servlet</h2><p>web开发基石，与平台无关的服务器组件，负责与客户端进行通信</p><p>servlet本身是一堆接口，自定义一个类，并实现servlet</p><p>客户端无法直接访问servlet，只能在服务器端添加映射才能访问</p><p>映射需要开发者手动配置，有两种：</p><ul><li><p>基于xml的配置方式，直接手写映射</p></li><li><p>基于注解的方式，在需要映射的类名上方使用@添加注释</p><p>上述两种配置方法结果一致</p></li></ul><h3 id="1-servlet功能"><a href="#1-servlet功能" class="headerlink" title="1.servlet功能"></a>1.servlet功能</h3><ul><li>创建并返回给予客户请求的动态页面</li><li>与数据库进行通信</li></ul><h3 id="2-servlet生命周期"><a href="#2-servlet生命周期" class="headerlink" title="2.servlet生命周期"></a>2.servlet生命周期</h3><ol><li><p>当浏览器访问servle的时候，Tomcat会查询当前servlet的实例化对象是否存在，<u>若不存在，则通过反射机制动态创建对象（运行时类，获取类名-》获取构造器-》调用构造器创建对象， 若存在则直接执行第三步操作）</u></p></li><li><p>调用init方法完成初始化操作</p></li><li><p>调用service方法完成业务逻辑操作</p></li><li><p>关闭Tomcat时，调用destroy方法，释放当前占用资源</p><p>​    servlet生命周期方法：无参构造函数，init，service，destroy</p></li></ol><h3 id="3-servletconfig"><a href="#3-servletconfig" class="headerlink" title="3.servletconfig"></a>3.servletconfig</h3><p>该接口用来描述servlet的基本信息</p><ul><li>getservletname()  获取全类名</li><li>getinitparameter(string key)  过去init参数值(web.xml)</li><li>getinitparametername() 返回所有的initparameter的name值，用于遍历所有初始化值</li><li>getservletcontent 返回servletcontext，它是servlet的上下文，整个servlet的管理者</li></ul><h4 id="servletconfig与servletcontext的区别："><a href="#servletconfig与servletcontext的区别：" class="headerlink" title="servletconfig与servletcontext的区别："></a>servletconfig与servletcontext的区别：</h4><p>config作用于某个servlet对象，context作用于整个web应用</p><p>config具体实例，context全局</p><h3 id="4-servlet的层次结构"><a href="#4-servlet的层次结构" class="headerlink" title="4.servlet的层次结构"></a>4.servlet的层次结构</h3><p>servlet-》genericservlet（屏蔽常用方法）-》Httpservlet（处理HTTP请求）</p><ul><li>Genericservlet实现了servlet接口，同时为它的子类屏蔽不常用方法，子类只需要重写service方法，HTTPservice方法即可</li><li>HTTPservlet继承Genericservlet，根据请求类型进行分发处理，GET进入doGET方法等</li></ul><p>开发者自定义servlet只需继承HTTPservlet即可</p><h4 id="HTTP请求类型："><a href="#HTTP请求类型：" class="headerlink" title="HTTP请求类型："></a>HTTP请求类型：</h4><ul><li>Get 读</li><li>post 存</li><li>put 放</li><li>delete 删</li></ul><h2 id="JSP"><a href="#JSP" class="headerlink" title="JSP"></a>JSP</h2><p>PS：jsp会将写入的代码转化为servlet，在调用write（）方法将HTML内容逐行输出</p><p> JSP本质上就是一个servlet，jsp主要负责于用户交互，将最终的界面全部呈现给用户，即HTML+CSS+JS混合文件</p><p> Tomcat会将jsp转化为servlet，将代码逐行输出，所有信息组合成完整的HTML代码</p><h3 id="1-转换流程"><a href="#1-转换流程" class="headerlink" title="1.转换流程"></a>1.转换流程</h3><p>​              <img src="/2022/02/23/servelet/Users/khdiu\AppData\Roaming\Typora\typora-user-images\image-20211126203817591.png" alt="image-20211126203817591" style="zoom: 50%;"></p><h3 id="2-HTML中嵌入JAVA程序"><a href="#2-HTML中嵌入JAVA程序" class="headerlink" title="2.HTML中嵌入JAVA程序"></a>2.HTML中嵌入JAVA程序</h3><ol><li>jsp脚本：执行JAVA代码用&lt;% code %&gt;单标签</li><li>jsp声明：定义JAVA方法用&lt;%! code%&gt;单标签</li><li>jsp表达式：把JAVA对象直接输出到HTML页中&lt;%&#x3D; java变量%&gt;</li></ol><h3 id="3-jsp内置对象"><a href="#3-jsp内置对象" class="headerlink" title="3.jsp内置对象"></a>3.jsp内置对象</h3><ul><li>request 表示一次请求 Httpservletservice</li><li>response 表示一次响应 Httpservletresponse</li><li>pagecontext 页面上下文 获取页面信息 </li><li>session 表示一次会话 保存用户信息 Httpsession</li><li>applocation 表示当前web应用，全局对象，保存所有用户共享信息 servletcontext</li><li>config 当前就jsp对应servlet的servletconfig对象，获取当前的servlet信息</li><li>out 向浏览器输出数据 jspwriter</li><li>page 当前jsp对应的servlet对象 servlet</li><li>exception 表示jsp页面发生的异常</li></ul><h3 id="4-request常用方法"><a href="#4-request常用方法" class="headerlink" title="4.request常用方法"></a>4.request常用方法</h3><ol><li>string getparameter(string key)获取从客户端传来的参数</li><li>void setAttribute(string key,objerct value) 通过键值对</li><li>string getAttribute(string key) 源JSP调用getrequestDispatcher(jsp名).forward(request,response)将对象传递给其他的JSP，之后由其他JSP处理请求</li><li>requestDispatcher ，getrequestdispatcher(string path)返回一个requestdispatcher对象</li><li>string[] getparametervalues()获取客户端传来的多个同名参数</li><li>void setcharacterEncoding(string charset)指定每个请求的编码</li></ol><h3 id="5-response常用方法"><a href="#5-response常用方法" class="headerlink" title="5.response常用方法"></a>5.response常用方法</h3><p>senddirect(string path)重定向，页面之间的跳转</p><p><u>转发是将同请求传递给下个页面，重定向是创建一个新的请求给下一个页面，之前的请求结束生命周期</u></p><ul><li>转发：同一个请求在服务器之间的传毒，地址栏不变，也叫服务器跳转</li><li>重定向：由客户端发送一个新的请求来访问跳转后的目标资源，地址栏改变，也叫客户端跳转</li></ul><p><strong>如果两个页面之间需要通过request来传值，则必须使用转发，不能使用重定向</strong></p><p>如：用户名登录，则需要将用户名传递给下一个页面</p><h2 id="session会话"><a href="#session会话" class="headerlink" title="session会话"></a>session会话</h2><p><u>服务器无法识别每一次HTTP请求的出处(<strong>无法识别来自哪个终端</strong>)，它只会接受到一个请求信号，必须有一种技术让服务器知道请求来自哪，这就是会话技术</u></p><h3 id="会话："><a href="#会话：" class="headerlink" title="会话："></a>会话：</h3><p>​      就是客户端与服务器之间发生的一系列连续的请求和响应的过程，<strong>打开浏览器到关闭浏览器进行的过程操作</strong></p><h3 id="会话状态："><a href="#会话状态：" class="headerlink" title="会话状态："></a>会话状态：</h3><p>指服务器和浏览器在会话过程中产生的状态信息，借助于会话状态，服务器能够把属于同一次会话的一系列请求和响应关联起来</p><p>属于同一次会话的请求共用一个标识符，即session id（同一浏览器多个窗口属于同一会话，即共用同一id，关闭浏览器后再次打开，id刷新）</p><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><ul><li>string getid() 获取session id</li><li>vodi setmaxnactiveinterval（） 设置session失效时间，单位秒</li><li>int getmaxinactiveinterval 获取当前session的失效时间</li><li>void invalidate 设置session失效时间</li><li>void setattribute（string key，object value） 通过键值对存储数据</li><li>object getattribute(string key) 通过键值对获取对应数据</li><li>object removeattribute(string key) 通过键值对删除对应数据</li></ul><p><strong>session生命周期比request长，故用session存储用户名与密码</strong></p><h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><p>针对浏览器，不同浏览器使用不同的cookie</p><p>cookie是服务端在HTTP响应中附带传给浏览器的一个小文本文件，一旦浏览器保存了某个cookie，在之后的请求与响应过程中，会将此cookie来回传递，这样就可以通过cookie这个载体完成客户端与服务端的交互</p><p><strong>cookie本身也是javax.servlet中的类</strong></p><ul><li><p>创建cookie</p><p>调用responseaddcookie()将cookie写入客户端</p></li><li><p>读取cookie</p><p>request.getcookies()</p></li></ul><h3 id="cookie常用方法"><a href="#cookie常用方法" class="headerlink" title="cookie常用方法"></a>cookie常用方法</h3><p>void setmaxage(int age) 设置cookie的有效时间，单位秒</p><p>int getmaxage() 获取cookie的有效时间</p><p>string getName() 获取cookie的name</p><p>string getvalue() 获取cookie的value</p><h3 id="cookie与session的区别"><a href="#cookie与session的区别" class="headerlink" title="cookie与session的区别"></a>cookie与session的区别</h3><p>session：存在服务器 保存object类型</p><p>cookie：存在浏览器，保存的数据是string类型</p><p>安全： <strong>session保存重要内容，cookie保存不重要信息</strong></p>]]></content>
      
      
      <categories>
          
          <category> javaweb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/02/22/hello-world/"/>
      <url>/2022/02/22/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> common </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
