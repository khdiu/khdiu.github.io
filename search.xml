<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2022/02/23/servelet-%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/02/23/servelet-%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="javaweb"><a href="#javaweb" class="headerlink" title="javaweb"></a>javaweb</h1><p>Tomcat: web 应用服务器</p><h2 id="servlet"><a href="#servlet" class="headerlink" title="servlet"></a>servlet</h2><p>web开发基石，与平台无关的服务器组件，负责与客户端进行通信</p><p>servlet本身是一堆接口，自定义一个类，并实现servlet</p><p>客户端无法直接访问servlet，只能在服务器端添加映射才能访问</p><p>映射需要开发者手动配置，有两种：</p><ul><li><p>基于xml的配置方式，直接手写映射</p></li><li><p>基于注解的方式，在需要映射的类名上方使用@添加注释</p><p>上述两种配置方法结果一致</p></li></ul><h3 id="1-servlet功能"><a href="#1-servlet功能" class="headerlink" title="1.servlet功能"></a>1.servlet功能</h3><ul><li>创建并返回给予客户请求的动态页面</li><li>与数据库进行通信</li></ul><h3 id="2-servlet生命周期"><a href="#2-servlet生命周期" class="headerlink" title="2.servlet生命周期"></a>2.servlet生命周期</h3><ol><li><p>当浏览器访问servle的时候，Tomcat会查询当前servlet的实例化对象是否存在，<u>若不存在，则通过反射机制动态创建对象（运行时类，获取类名-》获取构造器-》调用构造器创建对象， 若存在则直接执行第三步操作）</u></p></li><li><p>调用init方法完成初始化操作</p></li><li><p>调用service方法完成业务逻辑操作</p></li><li><p>关闭Tomcat时，调用destroy方法，释放当前占用资源</p><p>​    servlet生命周期方法：无参构造函数，init，service，destroy</p></li></ol><h3 id="3-servletconfig"><a href="#3-servletconfig" class="headerlink" title="3.servletconfig"></a>3.servletconfig</h3><p>该接口用来描述servlet的基本信息</p><ul><li>getservletname()  获取全类名</li><li>getinitparameter(string key)  过去init参数值(web.xml)</li><li>getinitparametername() 返回所有的initparameter的name值，用于遍历所有初始化值</li><li>getservletcontent 返回servletcontext，它是servlet的上下文，整个servlet的管理者</li></ul><h4 id="servletconfig与servletcontext的区别："><a href="#servletconfig与servletcontext的区别：" class="headerlink" title="servletconfig与servletcontext的区别："></a>servletconfig与servletcontext的区别：</h4><p>config作用于某个servlet对象，context作用于整个web应用</p><p>config具体实例，context全局</p><h3 id="4-servlet的层次结构"><a href="#4-servlet的层次结构" class="headerlink" title="4.servlet的层次结构"></a>4.servlet的层次结构</h3><p>servlet-》genericservlet（屏蔽常用方法）-》Httpservlet（处理HTTP请求）</p><ul><li>Genericservlet实现了servlet接口，同时为它的子类屏蔽不常用方法，子类只需要重写service方法，HTTPservice方法即可</li><li>HTTPservlet继承Genericservlet，根据请求类型进行分发处理，GET进入doGET方法等</li></ul><p>开发者自定义servlet只需继承HTTPservlet即可</p><h4 id="HTTP请求类型："><a href="#HTTP请求类型：" class="headerlink" title="HTTP请求类型："></a>HTTP请求类型：</h4><ul><li>Get 读</li><li>post 存</li><li>put 放</li><li>delete 删</li></ul><h2 id="JSP"><a href="#JSP" class="headerlink" title="JSP"></a>JSP</h2><p>PS：jsp会将写入的代码转化为servlet，在调用write（）方法将HTML内容逐行输出</p><p> JSP本质上就是一个servlet，jsp主要负责于用户交互，将最终的界面全部呈现给用户，即HTML+CSS+JS混合文件</p><p> Tomcat会将jsp转化为servlet，将代码逐行输出，所有信息组合成完整的HTML代码</p><h3 id="1-转换流程"><a href="#1-转换流程" class="headerlink" title="1.转换流程"></a>1.转换流程</h3><p>​              <img src="C:\Users\khdiu\AppData\Roaming\Typora\typora-user-images\image-20211126203817591.png" alt="image-20211126203817591" style="zoom: 50%;" /></p><h3 id="2-HTML中嵌入JAVA程序"><a href="#2-HTML中嵌入JAVA程序" class="headerlink" title="2.HTML中嵌入JAVA程序"></a>2.HTML中嵌入JAVA程序</h3><ol><li>jsp脚本：执行JAVA代码用&lt;% code %&gt;单标签</li><li>jsp声明：定义JAVA方法用&lt;%! code%&gt;单标签</li><li>jsp表达式：把JAVA对象直接输出到HTML页中&lt;%&#x3D; java变量%&gt;</li></ol><h3 id="3-jsp内置对象"><a href="#3-jsp内置对象" class="headerlink" title="3.jsp内置对象"></a>3.jsp内置对象</h3><ul><li>request 表示一次请求 Httpservletservice</li><li>response 表示一次响应 Httpservletresponse</li><li>pagecontext 页面上下文 获取页面信息 </li><li>session 表示一次会话 保存用户信息 Httpsession</li><li>applocation 表示当前web应用，全局对象，保存所有用户共享信息 servletcontext</li><li>config 当前就jsp对应servlet的servletconfig对象，获取当前的servlet信息</li><li>out 向浏览器输出数据 jspwriter</li><li>page 当前jsp对应的servlet对象 servlet</li><li>exception 表示jsp页面发生的异常</li></ul><h3 id="4-request常用方法"><a href="#4-request常用方法" class="headerlink" title="4.request常用方法"></a>4.request常用方法</h3><ol><li>string getparameter(string key)获取从客户端传来的参数</li><li>void setAttribute(string key,objerct value) 通过键值对</li><li>string getAttribute(string key) 源JSP调用getrequestDispatcher(jsp名).forward(request,response)将对象传递给其他的JSP，之后由其他JSP处理请求</li><li>requestDispatcher ，getrequestdispatcher(string path)返回一个requestdispatcher对象</li><li>string[] getparametervalues()获取客户端传来的多个同名参数</li><li>void setcharacterEncoding(string charset)指定每个请求的编码</li></ol><h3 id="5-response常用方法"><a href="#5-response常用方法" class="headerlink" title="5.response常用方法"></a>5.response常用方法</h3><p>senddirect(string path)重定向，页面之间的跳转</p><p><u>转发是将同请求传递给下个页面，重定向是创建一个新的请求给下一个页面，之前的请求结束生命周期</u></p><ul><li>转发：同一个请求在服务器之间的传毒，地址栏不变，也叫服务器跳转</li><li>重定向：由客户端发送一个新的请求来访问跳转后的目标资源，地址栏改变，也叫客户端跳转</li></ul><p><strong>如果两个页面之间需要通过request来传值，则必须使用转发，不能使用重定向</strong></p><p>如：用户名登录，则需要将用户名传递给下一个页面</p><h2 id="session会话"><a href="#session会话" class="headerlink" title="session会话"></a>session会话</h2><p><u>服务器无法识别每一次HTTP请求的出处(<strong>无法识别来自哪个终端</strong>)，它只会接受到一个请求信号，必须有一种技术让服务器知道请求来自哪，这就是会话技术</u></p><h3 id="会话："><a href="#会话：" class="headerlink" title="会话："></a>会话：</h3><p>​      就是客户端与服务器之间发生的一系列连续的请求和响应的过程，<strong>打开浏览器到关闭浏览器进行的过程操作</strong></p><h3 id="会话状态："><a href="#会话状态：" class="headerlink" title="会话状态："></a>会话状态：</h3><p>指服务器和浏览器在会话过程中产生的状态信息，借助于会话状态，服务器能够把属于同一次会话的一系列请求和响应关联起来</p><p>属于同一次会话的请求共用一个标识符，即session id（同一浏览器多个窗口属于同一会话，即共用同一id，关闭浏览器后再次打开，id刷新）</p><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><ul><li>string getid() 获取session id</li><li>vodi setmaxnactiveinterval（） 设置session失效时间，单位秒</li><li>int getmaxinactiveinterval 获取当前session的失效时间</li><li>void invalidate 设置session失效时间</li><li>void setattribute（string key，object value） 通过键值对存储数据</li><li>object getattribute(string key) 通过键值对获取对应数据</li><li>object removeattribute(string key) 通过键值对删除对应数据</li></ul><p><strong>session生命周期比request长，故用session存储用户名与密码</strong></p><h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><p>针对浏览器，不同浏览器使用不同的cookie</p><p>cookie是服务端在HTTP响应中附带传给浏览器的一个小文本文件，一旦浏览器保存了某个cookie，在之后的请求与响应过程中，会将此cookie来回传递，这样就可以通过cookie这个载体完成客户端与服务端的交互</p><p><strong>cookie本身也是javax.servlet中的类</strong></p><ul><li><p>创建cookie</p><p>调用responseaddcookie()将cookie写入客户端</p></li><li><p>读取cookie</p><p>request.getcookies()</p></li></ul><h3 id="cookie常用方法"><a href="#cookie常用方法" class="headerlink" title="cookie常用方法"></a>cookie常用方法</h3><p>void setmaxage(int age) 设置cookie的有效时间，单位秒</p><p>int getmaxage() 获取cookie的有效时间</p><p>string getName() 获取cookie的name</p><p>string getvalue() 获取cookie的value</p><h3 id="cookie与session的区别"><a href="#cookie与session的区别" class="headerlink" title="cookie与session的区别"></a>cookie与session的区别</h3><p>session：存在服务器 保存object类型</p><p>cookie：存在浏览器，保存的数据是string类型</p><p>安全： <strong>session保存重要内容，cookie保存不重要信息</strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/02/22/hello-world/"/>
      <url>/2022/02/22/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
